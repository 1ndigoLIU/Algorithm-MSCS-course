下面是一份综合了所有 midterm 考试范围的复习笔记，内容涵盖了算法基础、分析方法、分治策略、递归与主定理、二分搜索以及各种排序算法（包括冒泡、选择、插入、归并、堆排序、快速排序和计数排序），同时还包括堆的性质和比较排序的基本性质。你可以在开卷考试时打开此.md文件快速查阅关键概念和算法细节。

---

# CS 5800 Algorithms Midterm Review Notes

> **考试范围：**
> - 算法基础（阅读 Python 代码和伪代码，理解算法正确性）
> - 算法运行时间分析、Big O、Theta 与 Omega 表示法、函数渐进增长
> - 分治法（分治步骤、运行时间分析、递归树、主定理）
> - 二分搜索算法
> - 各种排序算法：冒泡、选择、插入、归并、堆、快速、计数排序
> - 堆的性质（最大/最小堆）、二叉堆操作
> - 比较排序的性质

## 目录
1. [算法基础](#算法基础)
2. [算法分析与渐进符号](#算法分析与渐进符号)
3. [分治策略](#分治策略)
4. [递归关系与主定理](#递归关系与主定理)
5. [二分搜索](#二分搜索)
6. [排序算法](#排序算法)
   - [冒泡排序](#冒泡排序)
   - [选择排序](#选择排序)
   - [插入排序](#插入排序)
   - [归并排序](#归并排序)
   - [堆排序](#堆排序)
   - [快速排序](#快速排序)
   - [计数排序](#计数排序)
7. [堆数据结构与优先队列](#堆数据结构与优先队列)
8. [比较排序的基本性质](#比较排序的基本性质)
9. [补充内容](#补充内容)
10. [总结](#总结)

---

## 算法基础

- **算法的定义**  
  一个算法是一个明确的计算过程，它接受输入，经过有限的步骤产生输出。  
- **正确性**  
  算法应保证对所有有效输入都能产生正确的结果。  
- **阅读代码与伪代码**  
  能够理解 Python 代码和伪代码，并推理代码是否正确以及其运行流程。

---

## 算法分析与渐进符号

- **运行时间分析**  
  分析算法执行所需步骤的数量，通常以输入规模 n 的函数形式表示。
- **渐进符号**  
  - **Big O (O):** 上界，描述最坏情况的增长速度  
  - **Theta (Θ):** 紧确界，表示算法的精确渐进增长率  
  - **Omega (Ω):** 下界，描述算法至少需要的时间  
- **函数的渐进增长**  
  理解多项式、对数、指数等不同函数在 n→∞ 时的增长对比。

---

## 分治策略

- **核心思想**  
  将原问题分解为若干规模较小的子问题，递归求解后合并子问题的解得到原问题的解。  
- **三大步骤：**  
  1. **Divide (分解)：** 将问题划分成若干子问题  
  2. **Conquer (解决)：** 递归求解每个子问题  
  3. **Combine (合并)：** 将子问题的解组合成原问题的解  
- **实例：**  
  归并排序和二分搜索都是典型的分治法应用。

---

## 递归关系与主定理

- **递归关系**  
  表示一个算法运行时间 T(n) 与其子问题 T(n/b) 之间的关系。例如：  
  - **归并排序递归式：**  
    T(n) = 2T(n/2) + O(n)
- **求解方法**  
  - **代入法（Substitution）**  
  - **递归树（Recursion Tree）**  
  - **主定理（Master Theorem）**  
- **主定理概述**  
  针对形如 T(n) = aT(n/b) + f(n) 的递归关系，有以下三种情况：  
  1. 如果 f(n) = O(n^(log_b(a) - ε))，则 T(n) = Θ(n^(log_b(a)))  
  2. 如果 f(n) = Θ(n^(log_b(a)) · log^k(n))，则 T(n) = Θ(n^(log_b(a)) · log^(k+1)n)  
  3. 如果 f(n) = Ω(n^(log_b(a) + ε)) 并满足正则性条件，则 T(n) = Θ(f(n))

---

## 二分搜索

- **算法概念**  
  在有序数组中，每次比较后都能排除一半的元素，从而实现对目标值的快速查找。  
- **伪代码示例：**

```python
def binary_search(A, target, low, high):
    if low >= high:
        return False
    mid = low + (high - low) // 2
    if A[mid] == target:
        return True
    elif A[mid] < target:
        return binary_search(A, target, mid + 1, high)
    else:
        return binary_search(A, target, low, mid)
```

- **时间复杂度**  
  O(log n)

---

## 排序算法

### 冒泡排序

- **思想：**  
  多次遍历数组，每次比较相邻元素，若顺序错误则交换；较大的元素逐渐“冒泡”到数组末端。
- **时间复杂度：**  
  最坏情况 O(n²)

---

### 选择排序

- **思想：**  
  每一趟从未排序部分选择最小（或最大）的元素，放到已排序部分末尾。
- **伪代码示例：**

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr
```

- **时间复杂度：**  
  O(n²)

---

### 插入排序

- **思想：**  
  将数组分为已排序和未排序两部分，每次将未排序的第一个元素插入到已排序部分的正确位置。  
- **时间复杂度：**  
  最坏情况 O(n²)，最佳情况（近乎有序） O(n)

---

### 归并排序

- **思想：**  
  利用分治法将数组不断分割成小数组，然后将已排序的小数组归并成一个整体有序数组。
- **伪代码示例：**

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)
```

- **归并过程：**  
  将两个有序数组合并，时间复杂度 O(n)
- **递归式与时间复杂度：**  
  T(n) = 2T(n/2) + O(n) → Θ(n log n)

---

### 堆排序

- **思想：**  
  利用二叉堆数据结构先构建堆，然后反复将堆顶（最大或最小元素）与数组末尾交换，再对剩余部分进行堆化。  
- **堆构造：**  
  使用 Heapify 技术，整体建堆时间 O(n)  
- **排序过程：**  
  每次删除堆顶并堆化，整体时间 O(n log n)
- **伪代码示例：**

```python
def heap_sort(arr):
    build_max_heap(arr)
    for i in range(len(arr)-1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, index=0, size=i)
```

---

### 快速排序

- **思想：**  
  通过选取一个“枢纽”（pivot），将数组划分为左右两部分：左侧所有元素小于枢纽，右侧所有元素大于枢纽；然后递归排序左右子数组。  
- **分区过程：**  
  将数组重新排列，使得枢纽元素归位。  
- **伪代码示例：**

```python
def quick_sort(arr, low, high):
    if low < high:
        pivot_index = partition(arr, low, high)
        quick_sort(arr, low, pivot_index - 1)
        quick_sort(arr, pivot_index + 1, high)
```

- **时间复杂度：**  
  平均 O(n log n)，最坏情况 O(n²)（可用随机化选择 pivot 来改善）

---

### 计数排序

- **思想：**  
  通过统计每个元素出现的次数，进而确定每个元素在排序后的位置。  
- **适用场景：**  
  当输入的元素范围 k 不大于 n 时非常高效。
- **时间复杂度：**  
  O(n + k)，非比较型排序

---

## 堆数据结构与优先队列

- **二叉堆：**  
  - **定义：** 一个近乎完全二叉树，满足堆序性质  
  - **最大堆：** 每个节点的值均不小于其子节点  
  - **最小堆：** 每个节点的值均不大于其子节点  
- **基本操作：**  
  - **构建堆（Build Heap）：** O(n) 时间  
  - **插入（Insert）：** O(log n)  
  - **删除堆顶（Delete-Min/Max）：** O(log n)  
  - **查找堆顶（Get-Min/Max）：** O(1)
- **优先队列：**  
  抽象数据类型，支持插入、查找最小/最大元素以及删除最小/最大元素，通常用堆实现。

---

## 比较排序的基本性质

- **理论下界：**  
  任何基于比较的排序算法在最坏情况下至少需要 Ω(n log n) 次比较。  
- **稳定性：**  
  是否保持相等元素的相对顺序。  
- **原地性：**  
  是否在排序过程中只使用常量级额外空间。

---

## 补充内容

- **算法正确性证明：**  
  通过直接证明、数学归纳法和递归证明来验证算法的正确性。  
- **伪代码与 Python 代码：**  
  熟悉伪代码的描述和实际 Python 实现之间的转换。  
- **运行时间分析实例：**  
  分析嵌套循环（如选择排序）和分治递归（如归并排序）的具体步骤。

---

## 总结

- **掌握基本概念：** 理解算法的定义、正确性和设计思路。  
- **熟悉分析方法：** 包括对时间复杂度、渐进符号及递归关系的深入理解。  
- **分治与递归：** 重点理解分治算法、递归树以及主定理的应用。  
- **搜索与排序：** 理解二分搜索以及各种排序算法的实现细节与时间分析。  
- **数据结构：** 掌握二叉堆及其在堆排序和优先队列中的应用。  
- **参考性：** 在开卷考试时，这份笔记可作为快速查阅关键公式、算法伪代码与分析方法的工具。

---

祝你考试顺利！

---

以上内容整理自课程讲义与课堂笔记，覆盖了 midterm 考试前六周的主要知识点。
